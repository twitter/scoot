// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/twitter/scoot/bazel/remoteexecution (interfaces: ExecutionClient,ActionCacheClient,ContentAddressableStorageClient)

// Package mock_remoteexecution is a generated GoMock package.
package mock_remoteexecution

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	remoteexecution "github.com/twitter/scoot/bazel/remoteexecution"
	grpc "google.golang.org/grpc"
	reflect "reflect"
)

// MockExecutionClient is a mock of ExecutionClient interface
type MockExecutionClient struct {
	ctrl     *gomock.Controller
	recorder *MockExecutionClientMockRecorder
}

// MockExecutionClientMockRecorder is the mock recorder for MockExecutionClient
type MockExecutionClientMockRecorder struct {
	mock *MockExecutionClient
}

// NewMockExecutionClient creates a new mock instance
func NewMockExecutionClient(ctrl *gomock.Controller) *MockExecutionClient {
	mock := &MockExecutionClient{ctrl: ctrl}
	mock.recorder = &MockExecutionClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockExecutionClient) EXPECT() *MockExecutionClientMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockExecutionClient) Execute(arg0 context.Context, arg1 *remoteexecution.ExecuteRequest, arg2 ...grpc.CallOption) (remoteexecution.Execution_ExecuteClient, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Execute", varargs...)
	ret0, _ := ret[0].(remoteexecution.Execution_ExecuteClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockExecutionClientMockRecorder) Execute(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockExecutionClient)(nil).Execute), varargs...)
}

// WaitExecution mocks base method
func (m *MockExecutionClient) WaitExecution(arg0 context.Context, arg1 *remoteexecution.WaitExecutionRequest, arg2 ...grpc.CallOption) (remoteexecution.Execution_WaitExecutionClient, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WaitExecution", varargs...)
	ret0, _ := ret[0].(remoteexecution.Execution_WaitExecutionClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WaitExecution indicates an expected call of WaitExecution
func (mr *MockExecutionClientMockRecorder) WaitExecution(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitExecution", reflect.TypeOf((*MockExecutionClient)(nil).WaitExecution), varargs...)
}

// MockActionCacheClient is a mock of ActionCacheClient interface
type MockActionCacheClient struct {
	ctrl     *gomock.Controller
	recorder *MockActionCacheClientMockRecorder
}

// MockActionCacheClientMockRecorder is the mock recorder for MockActionCacheClient
type MockActionCacheClientMockRecorder struct {
	mock *MockActionCacheClient
}

// NewMockActionCacheClient creates a new mock instance
func NewMockActionCacheClient(ctrl *gomock.Controller) *MockActionCacheClient {
	mock := &MockActionCacheClient{ctrl: ctrl}
	mock.recorder = &MockActionCacheClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockActionCacheClient) EXPECT() *MockActionCacheClientMockRecorder {
	return m.recorder
}

// GetActionResult mocks base method
func (m *MockActionCacheClient) GetActionResult(arg0 context.Context, arg1 *remoteexecution.GetActionResultRequest, arg2 ...grpc.CallOption) (*remoteexecution.ActionResult, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetActionResult", varargs...)
	ret0, _ := ret[0].(*remoteexecution.ActionResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetActionResult indicates an expected call of GetActionResult
func (mr *MockActionCacheClientMockRecorder) GetActionResult(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActionResult", reflect.TypeOf((*MockActionCacheClient)(nil).GetActionResult), varargs...)
}

// UpdateActionResult mocks base method
func (m *MockActionCacheClient) UpdateActionResult(arg0 context.Context, arg1 *remoteexecution.UpdateActionResultRequest, arg2 ...grpc.CallOption) (*remoteexecution.ActionResult, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateActionResult", varargs...)
	ret0, _ := ret[0].(*remoteexecution.ActionResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateActionResult indicates an expected call of UpdateActionResult
func (mr *MockActionCacheClientMockRecorder) UpdateActionResult(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateActionResult", reflect.TypeOf((*MockActionCacheClient)(nil).UpdateActionResult), varargs...)
}

// MockContentAddressableStorageClient is a mock of ContentAddressableStorageClient interface
type MockContentAddressableStorageClient struct {
	ctrl     *gomock.Controller
	recorder *MockContentAddressableStorageClientMockRecorder
}

// MockContentAddressableStorageClientMockRecorder is the mock recorder for MockContentAddressableStorageClient
type MockContentAddressableStorageClientMockRecorder struct {
	mock *MockContentAddressableStorageClient
}

// NewMockContentAddressableStorageClient creates a new mock instance
func NewMockContentAddressableStorageClient(ctrl *gomock.Controller) *MockContentAddressableStorageClient {
	mock := &MockContentAddressableStorageClient{ctrl: ctrl}
	mock.recorder = &MockContentAddressableStorageClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockContentAddressableStorageClient) EXPECT() *MockContentAddressableStorageClientMockRecorder {
	return m.recorder
}

// BatchReadBlobs mocks base method
func (m *MockContentAddressableStorageClient) BatchReadBlobs(arg0 context.Context, arg1 *remoteexecution.BatchReadBlobsRequest, arg2 ...grpc.CallOption) (*remoteexecution.BatchReadBlobsResponse, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchReadBlobs", varargs...)
	ret0, _ := ret[0].(*remoteexecution.BatchReadBlobsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchReadBlobs indicates an expected call of BatchReadBlobs
func (mr *MockContentAddressableStorageClientMockRecorder) BatchReadBlobs(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchReadBlobs", reflect.TypeOf((*MockContentAddressableStorageClient)(nil).BatchReadBlobs), varargs...)
}

// BatchUpdateBlobs mocks base method
func (m *MockContentAddressableStorageClient) BatchUpdateBlobs(arg0 context.Context, arg1 *remoteexecution.BatchUpdateBlobsRequest, arg2 ...grpc.CallOption) (*remoteexecution.BatchUpdateBlobsResponse, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchUpdateBlobs", varargs...)
	ret0, _ := ret[0].(*remoteexecution.BatchUpdateBlobsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchUpdateBlobs indicates an expected call of BatchUpdateBlobs
func (mr *MockContentAddressableStorageClientMockRecorder) BatchUpdateBlobs(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchUpdateBlobs", reflect.TypeOf((*MockContentAddressableStorageClient)(nil).BatchUpdateBlobs), varargs...)
}

// FindMissingBlobs mocks base method
func (m *MockContentAddressableStorageClient) FindMissingBlobs(arg0 context.Context, arg1 *remoteexecution.FindMissingBlobsRequest, arg2 ...grpc.CallOption) (*remoteexecution.FindMissingBlobsResponse, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindMissingBlobs", varargs...)
	ret0, _ := ret[0].(*remoteexecution.FindMissingBlobsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindMissingBlobs indicates an expected call of FindMissingBlobs
func (mr *MockContentAddressableStorageClientMockRecorder) FindMissingBlobs(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindMissingBlobs", reflect.TypeOf((*MockContentAddressableStorageClient)(nil).FindMissingBlobs), varargs...)
}

// GetTree mocks base method
func (m *MockContentAddressableStorageClient) GetTree(arg0 context.Context, arg1 *remoteexecution.GetTreeRequest, arg2 ...grpc.CallOption) (remoteexecution.ContentAddressableStorage_GetTreeClient, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTree", varargs...)
	ret0, _ := ret[0].(remoteexecution.ContentAddressableStorage_GetTreeClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTree indicates an expected call of GetTree
func (mr *MockContentAddressableStorageClientMockRecorder) GetTree(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTree", reflect.TypeOf((*MockContentAddressableStorageClient)(nil).GetTree), varargs...)
}
